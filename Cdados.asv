classdef Cdados
    %CDADOS Classe de objetoetos que armazenam os dados da simulacao
    
    properties
        Pulsos          % Classe com sinais para cada etapa do processador
        num_canais;     % Numero de canais do IC
        maxima;         % Selecao de n (maxima) canais por frame
        tipo_filtro;    % Tipo de filtro para o banco do IC
        tipo_env;       % Tipo de extracao da envoltoria
        fcorte_fpb;     % Frequencia de corte do FPB apos retificacao
        ordem_fpb;      % Ordem do FPB apos retificacao
        tipo_pulso;     % Formato de pulso eletrico
        largura_pulso1;	% Largura do pulso 1 (meia onda sem contar o interphase gap)
        largura_pulso2;	% Largura do pulso 2 (meia onda sem contar o interphase gap)
        interphase_gap;	% Intervalo entre as partes positiva e negativa do pulso
        taxa_est;       % Taxa de estimulacao do gerador de pulsos
        quant_bits;     % Numero de bits para divisao da faixa dinamica
        fat_comp;       % fator de compressao (expoente para a lei da potencia)
        fase_pulso;     % Fase inicial do pulso: Anodico (-) ou Catodico (+)
        amp_corr_T;     % Limiar da amplitude de corrente
        amp_corr_C;     % Maximo conforto para amplitude de corrente
        max_corr;       % Maxima corrente do gerador
        atraso;         % Atraso do envelope entre canais: 0 (sem atraso) ou 1 (com atraso)
        paciente;       % Utilizacao das informacoes do 'paciente padrao' da clase
        baixa_freq;       % Frequencia central do filtro de baixa frequencia
        nome;           % Nome do arquivo de entrada de audio
        freq_amost;
        NF = 15;       % Discretização da nova freq amost
        nome_reconst
        CorrDist       % Distribuição de corrente
        Spike_matrix   % Matriz de 
        V_mem
        Ap
        lambda = 3; % Monopolar 8-11mm / Bipolar 2-4mm
        dtn_A = 35e-3;
        

    end
    properties(Dependent)
        freq2;          % Frequencia de amostragem das ondas de corrente
    end
    
    methods
        function objeto=Cdados(Y)      %construtor
            if ~isa(Y,'Cprocessador')
                error('A entrada deve ser um objetoeto tipo Cprocessador.')
            end
            
            objeto.Pulsos = Y.Csinal_processador.corr_onda;
            objeto.num_canais = Y.num_canais;
            objeto.maxima = Y.maxima;
            objeto.tipo_filtro = Y.tipo_filtro;
            objeto.tipo_env = Y.tipo_env;
            objeto.fcorte_fpb = Y.fcorte_fpb;
            objeto.ordem_fpb = Y.ordem_fpb;
            objeto.tipo_pulso = Y.tipo_pulso;
            objeto.largura_pulso1 = Y.largura_pulso1;
            objeto.largura_pulso2 = Y.largura_pulso2;
            objeto.interphase_gap = Y.interphase_gap;
            objeto.taxa_est = Y.taxa_est;
            objeto.quant_bits = Y.quant_bits;
            objeto.fat_comp = Y.fat_comp;
            objeto.fase_pulso = Y.fase_pulso;
            objeto.amp_corr_T = Y.amp_corr_T;
            objeto.amp_corr_C = Y.amp_corr_C;
            objeto.max_corr = Y.max_corr;
            objeto.atraso = Y.atraso;
            objeto.paciente = Y.paciente;
            objeto.baixa_freq = Y.baixa_freq;
            objeto.nome = Y.nome;
            objeto.freq_amost = Y.freq_amost;
            
        end
        
        function f2 = get.freq2(objeto)
            f2 = objeto.NF*objeto.freq_amost;
        end
        
        function [ondas, tempo] = calcOndas(objeto)
            tmax = zeros(1,objeto.num_canais);
            for n = 1:objeto.num_canais
                vn = strcat('E',num2str(n));
                tc = objeto.Pulsos.(vn);
                tmax(n)=max(tc(:,1));
            end

            tend = max(tmax) + objeto.largura_pulso1 + objeto.interphase_gap + objeto.largura_pulso2;
            npoints = ceil(tend*objeto.freq2);
            tempo = (1:npoints)*1/objeto.freq2;
            ondas = zeros(objeto.num_canais,npoints);

            for n = 1:objeto.num_canais
                vn = strcat('E',num2str(n));
                tc = objeto.Pulsos.(vn);
                [~,ondas(n,:)] = calcOndas(tc, objeto.freq2, objeto.tipo_pulso, ...
                objeto.largura_pulso1, objeto.largura_pulso2, tempo);                
            end
        end
        
        function saida = vocoder(objeto,flag)
            saida = vocoder(objeto.Csinal_processador.env,objeto.freq_amost,objeto.tipo_vocoder,Cpaciente(objeto.paciente).bandas_freq_entrada,Cpaciente(objeto.paciente).sup_freq,Cpaciente(objeto.paciente).inf_freq,objeto.vet_tempo);
            if flag == 1
            nv = '_vocoder_hc.wav';
            audiowrite(char(strcat(objeto.nome_reconst,nv)),saida,objeto.freq_amost)
            end
        end
        
        function neural_vocoder(objeto,PulsosCorr,freq2,flag)
            [objeto.CorrDist,objeto.Spike_matrix, objeto.V_mem, objeto.Ap,objeto.audio_reconst] = neural_vocoder(PulsosCorr,objeto.num_canais,objeto.freq_amost,freq2,objeto.corr_esp,objeto.tipo_vocoder,objeto.lambda,objeto.dtn_A);
            %sound(objeto.audio_reconst,objeto.freq_amost)
            if flag == 1
            nv = strcat('_neural_vocoder_hc','.wav');
            audiowrite(char(strcat(objeto.nome_reconst,nv)),objeto.audio_reconst,objeto.freq_amost)
            end
        end 
        
    end
    
end

